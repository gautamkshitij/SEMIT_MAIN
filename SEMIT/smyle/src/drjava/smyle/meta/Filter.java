/*
This source file is part of Smyle, a database library.
For up-to-date information, see http://www.drjava.de/smyle
Copyright (C) 2001 Stefan Reich (doc@drjava.de)

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

For full license text, see doc/license/lgpl.txt in this distribution
*/

package drjava.smyle.meta;

import java.util.*;
import org.artsProject.mcop.*;
import drjava.smyle.*;

/** an object that holds conditions for filtering records; similar to
    "where" and "order by" clauses in SQL queries.<p>
    Subclasses of Filter are generated by the Smyle IDL compiler. */
public class Filter<T extends Struct<T>> {
  protected ArrayList<Filter<T>.Clause> clauses = new ArrayList<Filter<T>.Clause>();
  protected ArrayList<Function/*<T,Comparable>*/> order = new ArrayList<Function/*<T,Comparable>*/>();
  protected boolean reverse = false;
  
  public boolean matches(T t) {
    for (int i = 0; i < clauses.size(); i++)
      if (!clauses.get(i).matches(t))
        return false;
    return true;
  }
  
  public interface Clause {
    public boolean matches(T t);
    
    // for automagic indexing - return function that could
    // be indexed in order to speed up this clause
    public Function getFunction();
    public Object getValue();
  }
  
  protected class FunctionEquals<A> implements Clause {
    private final Function<T,A> f;
    private final A value;
    
    public FunctionEquals(Function<T,A> f, A value) {
      this.f = f;
      this.value = value;
    }
      
    public boolean matches(T t) {
      return MCOP.equals(value, f.of(t));
    }
    
    public Function getFunction() { return f; }
    public Object getValue() { return value; }
  }
  
  /*protected class FunctionComparator<A implements Comparable> implements Comparator<T> {
    private final Function<T,A> f;
    
    public FunctionComparator(Function<T,A> f) {
      this.f = f;
    }
    
    public int compare(T a, T b) {
      return f.of(a).compareTo(f.of(b));
    }
  }
  
  protected class BooleanFunctionComparator implements Comparator<T> {
    private final Function<T,Boolean> f;
    
    public BooleanFunctionComparator(Function<T,Boolean> f) {
      this.f = f;
    }
    
    public int compare(T a, T b) {
      return (f.of(a).booleanValue() ? 1 : 0) - (f.of(b).booleanValue() ? 1 : 0);
    }
  }*/
  
  public ArrayList<Function<T,Comparable>> _getOrder() {
    return (ArrayList) order;
  }
  
  public int _numClauses() {
    return clauses.size();
  }
  
  public Clause _getClause(int index) {
    return clauses.get(index);
  }
  
  /*public void _addClause(Filter<T>.Clause c) {
    clauses.add(c);
  }*/
  
  public boolean isReversed() {
    return reverse;
  }
  
  public <A implements Comparable> void _orderBy(Field<T,A> field) {
    order.add(field);
  }
  
  public void _setReverse(boolean b) {
    reverse = b;
  }
  
  public T _createMatchingElement() {
    T t = createElement();
    for (int i = 0; i < clauses.size(); i++) {
      Filter<T>.Clause c = clauses.get(i);
      Function f = c.getFunction();
      if (f instanceof Cascade)
        f = ((Cascade) f).f();
      if (f instanceof Field)
        t.setField(((Field) f).nr(), c.getValue());
    }
    return t;
  }
  
  protected T createElement() {
    throw new InternalSmyleError("not available in generic filters");
  }
}
