<html>
<head>
<title>SMYLE: Benchmark results</title>
</head>
<body bgcolor="#ffffff" text="#000000">
<table>
<tr>
<td valign="top">
<table>
<tr>
<td><a href="index.html"><img border="0" src="smyle_small.jpg"></a></td>
</tr>
<tr>
<td><a href="index.html">Home</a></td>
</tr>
<tr>
<td><a href="http://sourceforge.net/project/showfiles.php?group_id=34021">Download!</a></td>
</tr>
<tr>
<td><a href="features.html">Features</a></td>
</tr>
<tr>
<td><a href="benchmark.html">Benchmark</a></td>
</tr>
<tr>
<td><a href="users.html">Users</a></td>
</tr>
<tr>
<td><a href="gettingstarted.html">Getting started</a></td>
</tr>
<tr>
<td><a href="concepts.html">Concepts</a></td>
</tr>
<tr>
<td><a href="data_types.html">Data types</a></td>
</tr>
<tr>
<td><a href="javaapi/index.html">API (Java)</a></td>
</tr>
<tr>
<td><a href="gjapi/index.html">API (GJ)</a></td>
</tr>
<tr>
<td><a href="idioms.html">Idioms</a></td>
</tr>
<tr>
<td><a href="architecture.html">Architecture</a></td>
</tr>
<tr>
<td><a href="performance.html">Performance Tips</a></td>
</tr>
<tr>
<td><a href="idl.html">IDL Grammar</a></td>
</tr>
<tr>
<td><a href="browser.html">Browser</a></td>
</tr>
<tr>
<td><a href="schema_evolution.html">Schema evolution</a></td>
</tr>
<tr>
<td><a href="gj.html">GJ (Generic Java)</a></td>
</tr>
<tr>
<td><a href="limitations.html">Limitations</a></td>
</tr>
<tr>
<td><a href="history.html">History</a></td>
</tr>
<tr>
<td><a href="http://sourceforge.net/forum/forum.php?forum_id=106587">Help Forum</a></td>
</tr>
</table>
</td><td width="20"></td><td valign="top">
<h2>SMYLE: Benchmark results</h2>
  How does Smyle perform? Is it fast enough for real-life tasks?
  Well, see for yourself - and keep in mind that smaller bars
  represent higher speed:
  <p>
</p>
  
  <img src="comparison.gif">
  <p>
</p>
  
  (MySQL: 17.3s+28.6s = 45.9s ~ 2.200 records/s; Smyle: 2.0s+5.3s = 7.3s ~ 13.700 records/s)
  <p>
</p>
  Test environment: Athlon 1300 MHz, 448 MB RAM, Windows 2000, JDK 1.3 HotSpot Client VM<br>
  MySQL: 3.23.22-beta; localhost via TCP/IP; JDBC driver: MM.MySQL<br>
  Smyle: 0.3 (internal prebuild)
  <p>
</p>
  
  <h3>What does the benchmark do?</h3>
  
  It creates a table with two columns and
  inserts 100.000 rows. It then deletes all these rows again, one by
  one, through repeated queries on one of the two columns.
  <p>
</p>
  
  I tried to ensure ideal conditions for both databases. The Smyle
  benchmark uses only two snapshots; one for the insertion phase, and one for
  the deletion phase. In accordance, the MySQL table is locked before
  each phase and unlocked afterwards (to allow for write caching).
  <p>
</p>
  
  The SQL code manually creates an index on the table (without the index,
  the deletion phase takes about an order of magnitude longer). Smyle
  automagically creates an index as soon as it notices that one is needed.
  <p>
</p>
  
  You can read the sources in the Smyle CVS:
  <a href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/smyle/smyle/src/drjava/smyle/tests/SQLBench.java?rev=1.1&amp;content-type=text/vnd.viewcvs-markup">SQLBench.java</a> and
  <a href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/smyle/smyle/src/drjava/smyle/tests/SmyleBench.java?rev=1.11&amp;content-type=text/vnd.viewcvs-markup">SmyleBench.java</a>.
  <p>
</p>
  
  <h3>Why is Smyle so much faster?</h3>
  
  The main answer is: Because it's highly optimized. This also proves
  that Java programs, if written carefully, can be very efficient.
  <p>
</p>
  
  But I also have to mention that MySQL is a little handicapped in this
  comparison. I only use a single database connection throughout the whole
  benchmark; but every insert/delete command is sent individually
  (at least I suppose that's what the driver does). So in total,
  the driver has to perform 200.000 TCP roundtrips, which is quite a lot.
  <p>
</p>
  
  You may or may not consider this unfair, but after all, it's a real
  world setting. Assuming that only one process needs to access the
  database, the TCP communication is an unnecessary overhead that
  should better be eliminated. The only reason why this isn't possible
  with MySQL is because MySQL can't be used as a library. Smyle, on the
  other hand, can only be used as a library (and not as a standalone DB
  server).
  <p>
</p>
  
  Note: I tried to improve MySQL's scores by transmitting all commands at once,
  but unfortunately the driver I used, MM.MySQL, has a fixed size limit
  for every packet it sends, so this didn't work.
  If there's a way around this limitation (using a different driver?),
  please tell me.
  <p>
</p>
  
  <h3>Is this impressive result representative for actual application performance?</h3>
  
  In many cases, yes. There is actually only one case where Smyle
  doesn't perform quite as impressively: when it has to execute many small transactions.
  This will be significantly optimized by use of <i>write combining</i> in Smyle 0.9.
  <p>
</p>
  
</td>
</tr>
<tr>
<td colspan="3">
<hr>
<table width="100%">
<tr>
<td>
          Author: Stefan Reich (<a href="mailto:doc@drjava.de">doc@drjava.de</a>)<br>
          Smyle Homepage: <a href="http://www.drjava.de/smyle/">www.drjava.de/smyle</a>
<br>
</td><td align="right"><A href="http://sourceforge.net"><IMG src="http://sourceforge.net/sflogo.php?group_id=34021" width="88" height="31" border="0" alt="SourceForge Logo"></A></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
</html>
